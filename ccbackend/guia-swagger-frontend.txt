Endpoints Existentes en la API
1. Para apelaciones.tsx (Listado Principal)
Este componente se encarga de mostrar la lista de todas las apelaciones.

Endpoint Recomendado: GET /apelaciones

Justificaci√≥n: Este endpoint es ideal. Tu documentaci√≥n Swagger indica que soporta paginaci√≥n (page, limit) y filtros clave como estado ("pendiente", "resuelta", "rechazada") y search, que son fundamentales para un listado de este tipo.

2. Para apelaciones-nueva.tsx (Formulario de Creaci√≥n)
Este componente es la p√°gina para crear una "Nueva Apelaci√≥n".

Endpoint Recomendado: POST /apelaciones

Justificaci√≥n: Es el endpoint de creaci√≥n. Seg√∫n la API, espera un multa_id y un motivo en el body, que son los datos que este formulario debe recolectar y enviar.

3. Para [id].tsx (Vista de Detalle)
Este componente carga y muestra los detalles de una apelaci√≥n espec√≠fica usando getApelacion(Number(id)).

Endpoint Recomendado: GET /apelaciones/{id}

Justificaci√≥n: Es el endpoint perfecto para obtener un recurso √∫nico. El id de la URL se usa para consultar la API y obtener la informaci√≥n detallada de esa apelaci√≥n en particular.

4. Para editar.tsx (Formulario de Edici√≥n)
Este componente es m√°s complejo: primero carga los datos de una apelaci√≥n y luego permite enviarlos.

Endpoint (Para Cargar Datos): GET /apelaciones/{id}

Justificaci√≥n: El componente usa getApelacion(Number(id)) en un useEffect para rellenar el formulario con los datos existentes (motivo y documentos_json).

Endpoint (Para Guardar Datos): (Ver secci√≥n de faltantes).

Endpoints Adicionales Recomendados (Faltantes en la API)
Tu c√≥digo de React espera poder realizar m√°s acciones de las que tu swagger.json documenta actualmente.

1. Endpoint para Actualizar (Editar)
Endpoint Sugerido: PATCH /apelaciones/{id} (o PUT /apelaciones/{id})

Justificaci√≥n: Tu archivo editar.tsx tiene una funci√≥n handleSubmit que llama a updateApelacion(Number(id), form, token). Esto es una actualizaci√≥n. Sin embargo, la API no define un m√©todo PATCH o PUT para /apelaciones/{id}. Necesitas agregar este endpoint para que el formulario de edici√≥n pueda guardar los cambios en el motivo o documentos_json.

2. Endpoint para Listar Multas Apelables
Endpoint Sugerido: GET /multas/mis-multas?apelable=true (o similar)

Justificaci√≥n: El formulario apelaciones-nueva.tsx necesita enviar un multa_id (requerido por el POST /apelaciones). El usuario no puede adivinar ese ID. La UI necesitar√° mostrar un listado o un selector con las multas que el usuario puede apelar. La secci√≥n Multas de tu API no tiene endpoints definidos, por lo que este ser√≠a crucial.

3. Endpoints para Cambiar Estado (Administraci√≥n)
Endpoint Sugerido: PATCH /apelaciones/{id}/resolver

Justificaci√≥n: El listado filtra por estado ("resuelta", "rechazada"), y la vista de detalle [id].tsx menciona onResolved. Esto implica que un administrador debe poder cambiar el estado de una apelaci√≥n de "pendiente" a "resuelta" o "rechazada", probablemente a√±adiendo un comentario de resoluci√≥n. No deber√≠as usar el PATCH gen√©rico para esto, sino un endpoint de acci√≥n espec√≠fico.

4. Endpoint para Eliminar
Endpoint Sugerido: DELETE /apelaciones/{id}

Justificaci√≥n: Para completar el CRUD (Crear, Leer, Actualizar, Borrar), faltar√≠a la opci√≥n de eliminar. Esto permitir√≠a a un usuario (si a√∫n est√° "pendiente") o a un administrador borrar una apelaci√≥n.


==========================================================

Este es uno de los m√≥dulos con mayor desajuste entre lo que el frontend (React) espera y lo que la API ofrece actualmente. El componente bitacora.tsx es un log de auditor√≠a de sistema muy avanzado, mientras que la API solo define un log de conserjer√≠a.

Aqu√≠ tienes el desglose:

1. Para bitacora.tsx (Listado Principal)
Este componente es una vista de log de auditor√≠a compleja que espera cargar estad√≠sticas, filtrar por m√∫ltiples criterios (tipo, prioridad, fecha, texto) y mostrar un timeline.

Endpoints Existentes (No coincidentes)
Endpoint Existente: GET /api/reportes/comunidad/{comunidadId}/bitacora-conserjeria

Justificaci√≥n / Problema: Este es el √∫nico endpoint de bit√°cora que encontr√© en tu Swagger. Sin embargo, el componente bitacora.tsx no es una bit√°cora de conserjer√≠a.

An√°lisis del Desajuste:

Tipos de Log: Tu UI filtra por tipos (system, user, security, maintenance, admin, financial). El endpoint de "conserjer√≠a" probablemente no maneje estos tipos de auditor√≠a de sistema.

Prioridades: Tu UI filtra por prioridad (low, normal, high, critical). El endpoint de conserjer√≠a no parece soportar esto.

Estad√≠sticas: Tu UI necesita Stats Cards (Total, Hoy, Prioridad Alta, Cr√≠ticas). El endpoint actual no provee estas estad√≠sticas.

üí° Endpoints Sugeridos (Faltantes en la API)
Para que el componente bitacora.tsx funcione como est√° dise√±ado, necesitar√≠as los siguientes endpoints:

GET /bitacora/comunidad/{comunidadId} (o /bitacora si es global)

Prop√≥sito: Este ser√≠a el endpoint principal para obtener la lista de actividades (activities).

Filtros Requeridos (Query Params): Para que los filtros de la UI funcionen, este endpoint debe aceptar:

search (para el texto de b√∫squeda)

type (para filtrar por system, user, security, etc.)

priority (para filtrar por low, normal, high, etc.)

dateRange (o fecha_desde / fecha_hasta)

page y limit (para la paginaci√≥n)

GET /bitacora/stats/{comunidadId}

Prop√≥sito: Para poblar las "Stats Cards".

Respuesta Esperada: Un JSON con la estructura { total: number, today: number, high: number, critical: number }.

GET /bitacora/export

Prop√≥sito: El componente tiene botones para exportar a CSV, Excel y PDF.

Funcionamiento: Deber√≠a aceptar los mismos filtros que el GET principal (search, type, priority, etc.) y devolver el archivo generado.

2. Para nueva.tsx (Formulario de Creaci√≥n)
Este componente es un formulario para crear manualmente una nueva entrada en la bit√°cora.

Endpoints Existentes
(Ninguno)

üí° Endpoints Sugeridos (Faltantes en la API)
POST /bitacora/comunidad/{comunidadId} (o /bitacora)

Prop√≥sito: Es el endpoint fundamental que falta. La funci√≥n handleSubmit en nueva.tsx necesita llamar a este endpoint para guardar la nueva entrada.

Body (Schema) Requerido: Deber√≠a aceptar un JSON con:

type (string)

priority (string)

title (string)

description (string)

tags (array de strings)

attachments (array de IDs de archivos, ver punto siguiente)

POST /api/files/upload (¬°Este ya existe!)

Prop√≥sito: El formulario nueva.tsx tiene una secci√≥n avanzada para subir archivos (drag and drop).

Recomendaci√≥n: No necesitas un endpoint nuevo para esto. El flujo de guardado en handleSubmit deber√≠a ser:

Si el usuario adjunt√≥ archivos, subirlos primero usando POST /api/files/upload (que ya est√° en tu Swagger).

Recoger los IDs de los archivos subidos.

Llamar a tu nuevo endpoint POST /bitacora e incluir esos IDs en el campo attachments.

==========================================================


Este m√≥dulo est√° muy bien cubierto por tu API. Cada componente de React tiene un endpoint casi id√©ntico esperando en la documentaci√≥n.

Aqu√≠ tienes el an√°lisis detallado:

Endpoints Existentes en la API
1. Para cargos.tsx y cargos-simple.tsx (Listado General)
Estos componentes act√∫an como la p√°gina principal del m√≥dulo, cargando un listado general de cargos (probablemente para un administrador).

Endpoint Recomendado: GET /cargos/comunidad/{comunidadId}

Justificaci√≥n: Este es el endpoint principal para obtener la lista de todas las cuentas de cobro de una comunidad. Tu API indica que soporta filtros clave que un listado as√≠ necesita: estado, unidad, periodo y paginaci√≥n (page, limit).

2. Para [unidad].tsx (Cargos por Unidad)
Este componente renderiza la p√°gina CargosUnidadPage, dise√±ada para mostrar el historial de cargos de una sola unidad.tsx].

Endpoint Recomendado: GET /cargos/unidad/{id}

Justificaci√≥n: Es la coincidencia perfecta. El componente llama a cargosApi.getByUnidad(parseInt(unidad)).tsx], y este endpoint en tu API se define como "Obtener historial de cuentas de cobro de una unidad".

3. Para [id].tsx (Detalle de Cargo)
Este componente muestra la vista detallada de un cargo espec√≠fico.tsx].

Endpoint Recomendado: GET /cargos/{id}

Justificaci√≥n: Es el endpoint est√°ndar para obtener un √∫nico recurso. El componente llama a cargosApi.getById(parseInt(id)).tsx], que coincide directamente con este endpoint.

4. Para nuevo.tsx (Formulario de Creaci√≥n)
Este componente es la p√°gina NuevoCargoPage, un formulario para crear un nuevo cargo.

Endpoint Recomendado: POST /cargos

Justificaci√≥n: Es una coincidencia exacta. El formulario recolecta concept, type, amount, dueDate y unit. El requestBody del endpoint POST /cargos en tu API espera exactamente esos mismos campos.

Endpoints Adicionales Recomendados (CRUD y Sugerencias)
Tu API ya cubre la mayor√≠a de las necesidades de estos componentes, pero aqu√≠ tienes algunas sugerencias para completar el m√≥dulo y enriquecer las vistas.

1. Endpoints Faltantes para un CRUD Completo
Aunque tus archivos React actuales no tienen una p√°gina de "Editar" (como s√≠ la ten√≠a Apelaciones) o un bot√≥n de "Eliminar", un m√≥dulo de cargos inevitablemente los necesitar√°.

PATCH /cargos/{id} (Sugerido)

Prop√≥sito: Para crear una futura p√°gina cargos/editar/[id].tsx. Permitir√≠a modificar un cargo existente (ej. cambiar el monto, la fecha de vencimiento o la descripci√≥n) si a√∫n est√° en estado "pendiente".

DELETE /cargos/{id} (Sugerido)

Prop√≥sito: Para permitir que un administrador elimine un cargo que fue creado por error.

2. Endpoints Sugeridos para Enriquecer las Vistas
Tu API ya tiene endpoints que har√≠an tus vistas de detalle y listado mucho m√°s potentes:

Para [id].tsx (Detalle de Cargo):

GET /cargos/{id}/detalle: Tu API lo define como "Obtener detalle de gastos que componen un cargo". Ser√≠a ideal llamarlo dentro de la p√°gina de detalle para mostrar al usuario por qu√© se le est√° cobrando ese monto.

GET /cargos/{id}/pagos: La API indica que esto obtiene los "pagos aplicados a un cargo". Es fundamental para la p√°gina de detalle, para mostrar el historial de pagos y el saldo restante de ese cargo espec√≠fico.

Para cargos.tsx (Listado General / Dashboard):

GET /cargos/comunidad/{comunidadId}/estadisticas: Provee un resumen de total_cargos, saldo_total, cargos_pagados, cargos_pendientes, etc.. Perfecto para mostrar "Stats Cards" en la parte superior del listado.

GET /cargos/comunidad/{comunidadId}/vencidos: Un endpoint dedicado para obtener un reporte de morosidad. Es una funci√≥n clave en cualquier sistema de administraci√≥n.

==========================================================


Este m√≥dulo es un excelente ejemplo de coincidencia entre tu frontend de React y la API. Tu swagger.json tiene endpoints espec√≠ficos para casi todas las acciones que tus componentes necesitan realizar.

Endpoints Existentes en la API
1. Para categorias-gasto.tsx (Listado Principal)
Este componente es una p√°gina de gesti√≥n completa: lista, filtra, muestra estad√≠sticas y maneja la eliminaci√≥n.

GET /categorias-gasto:

Coincidencia: Perfecta. Es el endpoint global para el listado. La funci√≥n loadCategories debe usar este endpoint. La API soporta los filtros que tu UI tiene (nombre_busqueda, tipo_filtro, activa_filtro), que coinciden con los filtros de b√∫squeda, comunidad y estado del componente.

GET /categorias-gasto/comunidad/{comunidadId}/dashboard/resumen:

Coincidencia: Perfecta. Tu UI muestra "Stats Cards" de "Total Categor√≠as" y "Categor√≠as Activas". Este endpoint devuelve exactamente esos datos: total_categorias y categorias_activas.

DELETE /categorias-gasto/{id}:

Coincidencia: Perfecta. El componente tiene una funci√≥n handleDeleteCategory y un modal de confirmaci√≥n confirmDelete. Este es el endpoint que debe llamarse para eliminar la categor√≠a seleccionada.

2. Para nueva.tsx (Formulario de Creaci√≥n)
Este componente es la p√°gina para crear una nueva categor√≠a, vinculada desde el bot√≥n "Nueva Categor√≠a".

POST /categorias-gasto/comunidad/{comunidadId}:

Coincidencia: Perfecta. Este es el endpoint de creaci√≥n. El formulario nueva.tsx (aunque es un placeholder) deber√° recolectar nombre, tipo, cta_contable y activa, que son los campos que espera el requestBody de este endpoint.

Nota: El frontend necesitar√° obtener el {comunidadId} (probablemente del usuario logueado o un selector) para poder llamar a este endpoint.

3. Para editar.tsx y [id].tsx (Formulario de Edici√≥n)
Estos archivos implementan la p√°gina para editar una categor√≠a existente.

GET /categorias-gasto/{id}:

Coincidencia: Perfecta. El componente usa categoriasGastoApi.getById(Number(id)) en un useEffect para cargar los datos de la categor√≠a y rellenar el formulario. Esto coincide exactamente con este endpoint.

PATCH /categorias-gasto/{id}:

Coincidencia: Perfecta. La funci√≥n handleSubmit del componente llama a categoriasGastoApi.update(categoria.id, updateData). Esto se asigna directamente al endpoint PATCH de la API, y el requestBody (nombre, tipo, cta_contable, activa) coincide con el objeto updateData que construye el c√≥digo.

Endpoints Adicionales Recomendados (Sugerencias)
Tu API ya es muy completa para este m√≥dulo. M√°s que endpoints faltantes, te sugiero c√≥mo usar otros endpoints que ya existen para hacer tu UI m√°s robusta:

GET /categorias-gasto/{id}/tiene-gastos (Sugerido para Validaci√≥n):

Prop√≥sito: Este endpoint de tu API verifica si una categor√≠a ya tiene gastos asociados.

Recomendaci√≥n: En categorias-gasto.tsx, antes de activar el bot√≥n "Eliminar" o dentro de la funci√≥n handleDeleteCategory, deber√≠as llamar a este endpoint. Si devuelve true, puedes deshabilitar la eliminaci√≥n o mostrar un mensaje de advertencia mucho m√°s claro (ej. "Esta categor√≠a no se puede eliminar porque ya est√° siendo usada en N gastos").

GET /categorias-gasto/comunidad/{comunidadId}/activas (Sugerido para otros M√≥dulos):

Prop√≥sito: La API define este endpoint como "Lista de categor√≠as activas para dropdowns".

Recomendaci√≥n: Aunque no se usa en este m√≥dulo, es el endpoint perfecto que deber√°s consumir en m√≥dulos como Gastos (cuando crees o edites un gasto) para poblar el selector de "Categor√≠a".


==========================================================


Este es otro m√≥dulo donde tu API est√° muy bien preparada para las necesidades de tu frontend.

Endpoints Existentes en la API
1. Para centros-costo.tsx (Listado Principal)
Este componente es la p√°gina principal que muestra estad√≠sticas, filtros y un listado de todos los centros de costo.

GET /centros-costo/comunidad/{comunidadId}/filtrar:

Coincidencia: Perfecta. Es el endpoint ideal para la funci√≥n loadCentros. La API lo describe como "Listado con filtros avanzados y estad√≠sticas", y tu UI implementa CentroFilters (filtros de b√∫squeda y comunidad).

GET /centros-costo/comunidad/{comunidadId}/dashboard/resumen:

Coincidencia: Perfecta. El componente CentroStats espera datos como total, active, presupuestoTotal y ejecutado. Este endpoint, "Resumen de centros de costo para dashboard", es el indicado para proveer esas estad√≠sticas.

DELETE /centros-costo/{id}:

Coincidencia: Perfecta. El componente tiene un modal de confirmaci√≥n (showDeleteModal) y una funci√≥n confirmDeleteCentro que llama a deleteCentro(selectedCentro.id). Esto coincide directamente con este endpoint de la API.

2. Para nuevo.tsx (Formulario de Creaci√≥n)
Este componente es un formulario muy detallado para crear un nuevo centro de costo, con campos para presupuesto, responsabilidades, √≠cono y color.

POST /centros-costo/comunidad/{comunidadId}:

Coincidencia: Perfecta. La funci√≥n handleSubmit (actualmente simulada) debe llamar a este endpoint. La API lo define como "Crear nuevo centro de costo" y el formulario recolecta todos los datos que el requestBody necesitar√≠a (nombre, departamento, presupuesto, etc.).

3. Para [id].tsx (Vista de Detalle)
Este componente muestra la informaci√≥n detallada de un centro de costo, incluyendo su presupuesto, ejecuci√≥n y una lista de "Gastos Recientes".tsx].

GET /centros-costo/{id}/detalle:

Coincidencia: Perfecta. Ideal para la funci√≥n loadCostCenter.tsx]. La API lo define como "Detalle completo de un centro de costo con estad√≠sticas", lo cual incluye la informaci√≥n de presupuesto y ejecuci√≥n que la UI necesita.tsx].

GET /centros-costo/{id}/gastos:

Coincidencia: Perfecta. La funci√≥n loadExpenses.tsx] necesita poblar la lista de "Gastos Recientes". Este endpoint, "Gastos asociados al centro de costo", est√° dise√±ado exactamente para eso.

Endpoints Adicionales Recomendados (Sugerencias)
Tu API ya cubre casi todo. Las siguientes son sugerencias para completar el flujo y mejorar la seguridad de las acciones.

1. Endpoint para la P√°gina de Edici√≥n
PATCH /centros-costo/{id}:

Prop√≥sito: Aunque no subiste el archivo editar.tsx para este m√≥dulo, tanto el listado (handleEditCenter) como el detalle (handleEdit).tsx] tienen botones de "Editar" que redirigen a la p√°gina de edici√≥n.

Recomendaci√≥n: Esa p√°gina de edici√≥n (ej. /centros-costo/editar/[id].tsx) deber√° usar este endpoint, que ya existe en tu API, para guardar los cambios.

2. Endpoint para Validaci√≥n (Mejora de UX)
GET /centros-costo/{id}/tiene-gastos:

Prop√≥sito: Tu API ya tiene este endpoint que verifica si un centro de costo tiene gastos asociados.

Recomendaci√≥n: En centros-costo.tsx, antes de activar el bot√≥n "Eliminar" o dentro de la funci√≥n handleDeleteCentro, deber√≠as llamar a este endpoint. Si devuelve true, puedes mostrar una advertencia m√°s clara o deshabilitar la eliminaci√≥n para prevenir la p√©rdida de datos hist√≥ricos.

3. Endpoint para Selects/Dropdowns
GET /centros-costo/comunidad/{comunidadId}/dropdown:

Prop√≥sito: Endpoint existente en la API para obtener una "Lista de centros de costo para dropdowns".

Recomendaci√≥n: Este endpoint ser√° fundamental cuando construyas el m√≥dulo de Gastos, ya que el formulario para crear un gasto necesitar√° poblar un selector de "Centro de Costo".


==========================================================


Este componente muestra un listado avanzado de compras con estad√≠sticas, filtros y una tabla.

Endpoint Recomendado (Existente): GET /compras

Justificaci√≥n: Este endpoint es una coincidencia perfecta para el listado. La funci√≥n loadPurchases usa filtros como search, tipo_doc, fecha_desde y fecha_hasta, que son exactamente los par√°metros que define este endpoint en tu Swagger.

Endpoint Faltante (Sugerido): DELETE /compras/{id}

Justificaci√≥n: Tu UI tiene una funci√≥n handleDeletePurchase y un modal de confirmaci√≥n para eliminar una compra. Sin embargo, tu API no define un endpoint DELETE para la ruta /compras/{id}.

Nota: La API s√≠ tiene un DELETE /documentos-compra/{id}, pero esto parece ser para un concepto diferente. Necesitar√°s un endpoint DELETE que coincida con el GET /compras.

2. Para nuevo.tsx (Formulario de Creaci√≥n)
Este es un formulario muy complejo para crear una nueva "Solicitud de Compra". Recolecta tipo, prioridad, proveedor, centro de costo, categor√≠a, justificaci√≥n y una lista de √≠tems de compra (descripci√≥n, cantidad, precio unitario, etc.).

Endpoint Existente: (Ninguno coincide)

An√°lisis del Desajuste: El √∫nico endpoint de creaci√≥n relacionado es POST /documentos-compra/comunidad/{comunidadId}. Este endpoint espera un documento simple (folio, total, neto, iva), no una orden de compra compleja con m√∫ltiples √≠tems y un flujo de aprobaci√≥n como la que tu formulario nuevo.tsx est√° creando.

Endpoints Faltantes (Sugeridos):

POST /compras/comunidad/{comunidadId} (CR√çTICO)

Justificaci√≥n: Este es el endpoint fundamental que falta. La funci√≥n handleSubmit necesita un endpoint que acepte el objeto complejo de "Nueva Compra".

Schema (Body) Requerido: Deber√≠a aceptar un JSON similar a lo que define el formulario: tipo, prioridad, proveedor_id, centro_costo_id, categoria_id, descripcion, fecha_requerida, moneda, justificacion, y un array de items: [...].

GET /api/proveedores/comunidad/{comunidadId}/dropdown (Recomendado)

Justificaci√≥n: El formulario nuevo.tsx necesita cargar una lista de proveedores para el selector. Este endpoint de tu API est√° dise√±ado exactamente para eso ("Lista simple para selects/dropdowns").

GET /centros-costo/comunidad/{comunidadId}/dropdown (Recomendado)

Justificaci√≥n: El formulario nuevo.tsx necesita cargar centros de costo. Este endpoint de tu API es perfecto para poblar ese selector.

GET /categorias-gasto/comunidad/{comunidadId}/activas (Recomendado)

Justificaci√≥n: El formulario nuevo.tsx necesita cargar categor√≠as de gasto. Este endpoint de tu API ("Lista de categor√≠as activas para dropdowns") es el indicado.

3. Para [id].tsx (Vista de Detalle)
Este componente muestra un detalle completo de la compra, incluyendo √≠tems, proveedor, centro de costo y un historial. Tambi√©n tiene l√≥gica para Aprobar, Rechazar y Editar la compra.tsx].

Endpoint Existente (Parcial): GET /documentos-compra/{id}

Justificaci√≥n: El c√≥digo llama a comprasApi.getById(Number(id)).tsx]. Este es el √∫nico endpoint de detalle (GET por ID) que existe en la API relacionado con compras.

An√°lisis del Desajuste: La UI espera una gran cantidad de datos (√≠tems, historial, estado de aprobaci√≥n).tsx] que un simple "documento de compra" (como una factura) podr√≠a no tener.

Endpoints Faltantes (Sugeridos):

GET /compras/{id}/detalle (Sugerido)

Justificaci√≥n: Ser√≠a ideal un endpoint que devuelva el objeto "Compra" completo, incluyendo la lista de √≠tems, el historial de aprobaci√≥n y los detalles del proveedor/centro de costo, tal como la UI espera.tsx].

PATCH /compras/{id} (Sugerido)

Justificaci√≥n: La UI tiene un bot√≥n "Editar".tsx]. La p√°gina de edici√≥n (que probablemente sea compras/editar/[id].tsx) necesitar√° un endpoint PATCH para guardar los cambios. La API tiene PATCH /documentos-compra/{id}, pero de nuevo, es probable que se necesite uno para el objeto "Compra" completo.

POST /compras/{id}/aprobar (CR√çTICO)

Justificaci√≥n: La UI tiene un modal y una funci√≥n handleApprove.tsx]. Esta es una acci√≥n de flujo de trabajo que requiere su propio endpoint para cambiar el estado de la compra.

POST /compras/{id}/rechazar (CR√çTICO)

Justificaci√≥n: Similar al anterior, la funci√≥n handleReject.tsx] necesita un endpoint para registrar el rechazo y el motivo.

POST /compras/{id}/nota (Sugerido)

Justificaci√≥n: La UI tiene una funci√≥n addNote que agrega eventos a un "Historial" (Timeline).tsx]. Se necesita un endpoint para registrar estas notas en la base de datos.


==========================================================


Este es el m√≥dulo n√∫cleo de tu aplicaci√≥n y tu swagger.json tiene una cobertura excelente para √©l. Cada acci√≥n que tus componentes de React intentan realizar tiene un endpoint l√≥gico esperando en la API.

Endpoints Existentes en la API
1. Para comunidades.tsx (Listado Principal)
Este componente muestra un listado de comunidades con filtros y dos modos de vista (tarjetas y tabla). La l√≥gica clave aqu√≠ es que un superadmin ve todas las comunidades, mientras que un usuario normal ve solo sus comunidades.

GET /comunidades:

Coincidencia: Perfecta (para Superadmin). Este endpoint lista todas las comunidades con estad√≠sticas. Es el que debe llamar la funci√≥n loadComunidades cuando user.is_superadmin es true. Los filtros de la UI (busqueda) coinciden con los par√°metros de la API (nombre, direccion).

GET /comunidades/mis-membresias:

Coincidencia: Recomendado (para Usuarios No-Admin). El c√≥digo actual planea cargar todas las comunidades y filtrarlas localmente basado en user.memberships. Esto es ineficiente. Este endpoint de la API, "Obtener membres√≠as del usuario actual", est√° dise√±ado precisamente para este caso de uso y es mucho m√°s √≥ptimo.

DELETE /comunidades/{id}:

Coincidencia: Perfecta. El componente implementa una funci√≥n handleDelete que requiere confirmaci√≥n. Este es el endpoint que debe llamar dicha funci√≥n.

2. Para nueva.tsx (Formulario de Creaci√≥n y Edici√≥n)
Este componente es un formulario multi-paso que sirve tanto para crear como para editar una comunidad, dependiendo de si id est√° presente en la URL.

POST /comunidades:

Coincidencia: Perfecta (para Creaci√≥n). La funci√≥n handleSubmit (cuando isEditing es false) debe llamar a este endpoint. El requestBody de la API (razon_social, rut, dv, direccion, email_contacto, telefono_contacto) coincide con los campos del formData del Paso 1 (nombre, rut, dv, direccion, email, telefono).

GET /comunidades/{id}:

Coincidencia: Perfecta (para Cargar Datos en Edici√≥n). Cuando isEditing es true, el useEffect llama a loadComunidadData. Esta funci√≥n debe usar este endpoint para obtener los datos de la comunidad y rellenar el formulario.

PATCH /comunidades/{id}:

Coincidencia: Perfecta (para Guardar Edici√≥n). La funci√≥n handleSubmit (cuando isEditing es true) debe llamar a este endpoint para guardar los cambios.

3. Para [id].tsx (Vista de Detalle)
Este es un componente de dashboard muy complejo con m√∫ltiples pesta√±as que cargan datos din√°micamente.tsx]. Tu API est√° perfectamente preparada para esto.

GET /comunidades/{id}:

Coincidencia: Perfecta (Carga Inicial). Se usa en la funci√≥n loadComunidad.tsx] para obtener la informaci√≥n principal (nombre, direcci√≥n, KPIs del header como totalUnidades, saldoPendiente, morosidad).tsx].

GET /comunidades/{id}/amenidades:

Coincidencia: Perfecta (Pesta√±a "Resumen"). La funci√≥n loadAmenidades.tsx] se llama para poblar la tarjeta de "Amenidades" dentro de la pesta√±a de resumen. Este endpoint es el indicado.

GET /comunidades/{id}/edificios:

Coincidencia: Perfecta (Pesta√±a "Estructura"). La funci√≥n loadEdificios.tsx] se activa al hacer clic en la pesta√±a "Estructura" y debe usar este endpoint.

GET /comunidades/{id}/residentes:

Coincidencia: Perfecta (Pesta√±a "Residentes"). La funci√≥n loadResidentes.tsx] se activa para la pesta√±a "Residentes" y coincide exactamente con este endpoint.

GET /comunidades/{id}/estadisticas:

Coincidencia: Perfecta (Pesta√±a "Finanzas"). La funci√≥n loadEstadisticas.tsx] se usa para poblar los KPIs y el "Resumen del Mes" en la pesta√±a de finanzas.tsx, swagger.json].

GET /comunidades/{id}/documentos:

Coincidencia: Perfecta (Pesta√±a "Documentos"). La funci√≥n loadDocumentos.tsx] se activa para la pesta√±a "Documentos" y este es el endpoint que debe consumir.

Endpoints Adicionales y Sugerencias
GET /comunidades/{id}/flujo-caja (Sugerido):

Prop√≥sito: En la pesta√±a "Finanzas" de [id].tsx, tienes un placeholder para un gr√°fico de "Flujo de Caja - √öltimos 6 Meses".tsx]. Tu API ya tiene el endpoint perfecto para esto. Deber√≠as llamar a este endpoint junto con loadEstadisticas para poblar ese gr√°fico.

GET /comunidades/{id}/parametros (Sugerido):

Prop√≥sito: La vista de detalle [id].tsx tiene un bot√≥n de "Acciones" que linkea a "Par√°metros de cobranza".tsx]. La p√°gina de destino (ej. comunidades/[id]/parametros) debe usar este endpoint de la API para cargar y guardar esa configuraci√≥n.

Mejora de Filtros (Sugerido):

Prop√≥sito: Tu listado comunidades.tsx filtra por tipo y estado localmente.

Recomendaci√≥n: Ser√≠a m√°s eficiente si el backend soportara estos filtros. Te sugiero modificar el endpoint GET /comunidades para que acepte ?tipo= y ?estado= como query parameters, permitiendo un filtrado m√°s r√°pido del lado del servidor.


==========================================================


Endpoints Existentes en la API
1. Para conciliaciones.tsx (Listado Principal)
Este componente muestra el listado de todas las conciliaciones, filtros y tarjetas de estad√≠sticas.

GET /conciliaciones:

Coincidencia: Perfecta. Es el endpoint principal para el listado. La funci√≥n loadConciliaciones llama a conciliacionesApi.getAll(filters), que coincide directamente con este endpoint paginado.

GET /conciliaciones/comunidad/{comunidadId}/estadisticas:

Coincidencia: Recomendado. Tu UI calcula las estad√≠sticas (total, conciliadas, pendientes) localmente en el frontend. Ser√≠a mucho m√°s eficiente usar este endpoint de la API para obtener esas "Stats Cards" directamente desde el backend.

GET /conciliaciones/comunidad/{comunidadId}/por-estado:

Coincidencia: Alternativa. Es una alternativa al endpoint anterior si solo necesitas las estad√≠sticas agrupadas por estado.

2. Para nueva.tsx (Formulario de Creaci√≥n)
Este es un asistente complejo de 4 pasos para crear una nueva conciliaci√≥n, subir un archivo, procesarlo y revisarlo.

POST /conciliaciones/comunidad/{comunidadId}:

Coincidencia: Perfecta. Este es el endpoint que se debe llamar en el Paso 1 (Configuraci√≥n Inicial) o al final del proceso para "Guardar Borrador". Crear√° el registro principal de la conciliaci√≥n.

POST /api/files/upload (de la secci√≥n "Files"):

Coincidencia: Perfecta. Este endpoint (que ya existe en tu API) es el que debe usarse en el Paso 2 (Carga de Archivos) para subir el estado bancario (Excel/CSV).

PATCH /conciliaciones/{id}:

Coincidencia: Perfecta. Este endpoint se usa para "Actualizar estado de conciliaci√≥n". Es ideal para el bot√≥n final "Completar Conciliaci√≥n", que cambiar√≠a el estado de "pendiente" a "conciliado".

3. Para [id].tsx (Vista de Detalle)
Este componente muestra el resumen, estad√≠sticas y la lista de transacciones de una conciliaci√≥n espec√≠fica.tsx].

GET /conciliaciones/{id}:

Coincidencia: Perfecta. Es el endpoint principal para "Obtener conciliaci√≥n por ID con detalle completo". La UI carga los datos (mockConciliacion).tsx] y este endpoint provee exactamente esa informaci√≥n.

GET /conciliaciones/comunidad/{comunidadId}/pendientes:

Coincidencia: Recomendado. Este endpoint de la API lista "Movimientos bancarios pendientes de conciliaci√≥n". Es perfecto para poblar la pesta√±a "Diferencias" en tu UI.tsx].

üí° Endpoints Sugeridos (Faltantes en la API)
Tu UI, especialmente en los pasos de revisi√≥n, implica una granularidad que la API actual no detalla.

PATCH /conciliaciones/transaccion/{txId} (CR√çTICO)

Prop√≥sito: Tu UI en nueva.tsx (Paso 4) y en [id].tsx (pesta√±a Transacciones).tsx] muestra una lista de transacciones individuales con su estado (matched, unmatched, manual).tsx, nueva.tsx].

Justificaci√≥n: Necesitar√°s un endpoint para que el usuario pueda cambiar manualmente el estado de una √∫nica transacci√≥n (ej. "marcar como conciliada", "asignar a..."). Los endpoints existentes .../{id}/conciliar y .../descartar parecen operar sobre toda la conciliaci√≥n, no sobre una l√≠nea individual.

PATCH /conciliaciones/{id}/notas (Sugerido)

Prop√≥sito: La vista de detalle [id].tsx tiene un modal para "Editar Notas".tsx].

Justificaci√≥n: El endpoint PATCH /conciliaciones/{id} existente solo menciona "Actualizar estado". Ser√≠a bueno tener un endpoint espec√≠fico para actualizar campos de texto como las notas, o confirmar que el PATCH gen√©rico tambi√©n las acepta.

GET /bancos/cuentas (Sugerido)

Prop√≥sito: El formulario nueva.tsx tiene una lista hardcodeada de bancos y cuentas (Banco de Chile, Santander, etc.).

Justificaci√≥n: Esto deber√≠a venir de la API para que sea din√°mico. Un endpoint que devuelva las cuentas bancarias configuradas para la comunidad ser√≠a ideal.


==========================================================


Este es el m√≥dulo que presenta el mayor desajuste entre tu frontend de React y la API swagger.json. Tu frontend espera un sistema completo de Gesti√≥n Documental (DMS) con metadatos, categor√≠as, niveles de acceso, versionamiento y comentarios.

Tu API actual, en cambio, tiene dos secciones que no coinciden con esto:

Files (üìÅ): Es un servicio gen√©rico para subir y descargar archivos (POST /api/files/upload, GET /api/files/{id}). No gestiona los metadatos (categor√≠a, acceso, tags, etc.) que tu UI requiere.

DocumentosCompra (üìÑ): Est√° enfocado en facturas y documentos tributarios, no en la gesti√≥n de documentos generales como "Reglamentos" o "Actas".

B√°sicamente, el backend tiene un "disco duro" (la API Files), pero el frontend espera una "aplicaci√≥n" completa (un DMS) que a√∫n no est√° definida en la API.

Aqu√≠ est√° el desglose de lo que necesitar√≠as:

Endpoints Existentes (Para Usos Espec√≠ficos)
POST /api/files/upload

Coincidencia: Perfecta. Este es el endpoint que debes usar en nueva.tsx y editar.tsx para subir el archivo binario (PDF, DOCX, etc.). La UI de drag-and-drop debe llamar a este endpoint primero.

GET /comunidades/{id}/documentos

Coincidencia: Parcial. Este es el √∫nico endpoint que parece estar destinado a listar documentos. El listado documentos.tsx podr√≠a usarlo.

Problema: El swagger.json no define el response de este endpoint. No sabemos si devuelve la rica metadata (categor√≠a, acceso, tags, versi√≥n) que la UI espera.

GET /api/files/{id}

Coincidencia: Perfecta (para descargar). En [id].tsx, el bot√≥n "Descargar".tsx] debe llamar a este endpoint. No sirve para cargar los detalles de la p√°gina, solo para obtener el archivo.

DELETE /api/files/{id}

Coincidencia: Perfecta (para eliminar). La funci√≥n handleDelete en documentos.tsx debe llamar a este endpoint para eliminar el archivo.

üí° Endpoints Sugeridos (Faltantes en la API)
Para que tu frontend funcione como est√° dise√±ado, necesitar√≠as crear una nueva secci√≥n en la API (ej. /documentos) que gestione toda la metadata. El flujo ser√≠a: 1) Subir archivo a /api/files/upload y obtener un fileId, 2) Guardar metadata en /documentos usando ese fileId.

1. Para documentos.tsx (Listado)
GET /documentos/comunidad/{comunidadId} (Sugerido)

Justificaci√≥n: Se necesita un endpoint de listado que devuelva el objeto completo de metadatos (nombre, categor√≠a, acceso, tags, versi√≥n, fileId) que la UI de documentos.tsx espera para poder filtrar y mostrar. El GET /comunidades/{id}/documentos existente podr√≠a ser este, pero necesitar√≠a confirmaci√≥n de su response.

2. Para nueva.tsx (Creaci√≥n)
POST /documentos (CR√çTICO)

Justificaci√≥n: Este es el endpoint m√°s cr√≠tico que falta. Despu√©s de subir el archivo a POST /api/files/upload, la funci√≥n handleSubmit de nueva.tsx necesita llamar a este endpoint para guardar toda la metadata recolectada en el formulario (nombre, descripci√≥n, categor√≠a, acceso, tags, y el ID del archivo subido).

3. Para [id].tsx (Detalle)
GET /documentos/{id} (CR√çTICO)

Justificaci√≥n: El useEffect en [id].tsx.tsx] necesita un endpoint para obtener toda la metadata de un solo documento (nombre, descripci√≥n, tags, notas, etc.).tsx].

GET /documentos/{id}/versions (CR√çTICO)

Justificaci√≥n: La pesta√±a "Versiones" en [id].tsx.tsx] necesita este endpoint para cargar el historial de versiones del documento.

GET /documentos/{id}/comments (CR√çTICO)

Justificaci√≥n: La pesta√±a "Comentarios".tsx] necesita este endpoint para cargar los comentarios.

POST /documentos/{id}/comments (CR√çTICO)

Justificaci√≥n: La funci√≥n handleAddComment.tsx] necesita este endpoint para publicar un nuevo comentario.

4. Para editar.tsx (Edici√≥n)
GET /documentos/{id} (CR√çTICO)

Justificaci√≥n: El useEffect en editar.tsx necesita este endpoint para cargar los datos existentes en el formulario.

PATCH /documentos/{id} (CR√çTICO)

Justificaci√≥n: La funci√≥n handleSubmit (cuando no se sube un archivo nuevo) necesita este endpoint para guardar los cambios en la metadata (nombre, descripci√≥n, categor√≠a, acceso).

POST /documentos/{id}/versions (CR√çTICO)

Justificaci√≥n: La funci√≥n handleSubmit (cuando s√≠ se sube un archivo nuevo) necesita este endpoint para crear un nuevo registro de versi√≥n, asociando el nuevo fileId (obtenido de POST /api/files/upload) al documento.


==========================================================

Debo se√±alar que existe un desajuste conceptual importante aqu√≠:

Frontend (Tus archivos .tsx): Est√°n dise√±ados como un sistema de Gesti√≥n Documental general (DMS). Permiten subir cualquier tipo de archivo (PDF, DOCX, etc.) y asociarle metadatos como categor√≠a (legal, financiero), nivel de acceso, etiquetas, versiones y comentarios.tsx, documentos.tsx].

Backend (API DocumentosCompra): Est√° espec√≠ficamente dise√±ado para gestionar documentos estructurados de compra, como facturas o boletas. Espera campos espec√≠ficos como proveedor_id, tipo_doc, folio, fecha_emision, total, neto, iva, etc.. No maneja la subida directa de archivos binarios ni la metadata general que tu frontend espera (categor√≠as generales, acceso, versiones, comentarios).

Tus componentes React actuales no se pueden conectar directamente a los endpoints DocumentosCompra tal como est√°n. Sin embargo, puedo indicarte qu√© endpoints de DocumentosCompra usar√≠as si adaptaras tu frontend para trabajar con este tipo de documentos estructurados:

Endpoints Existentes en la API (DocumentosCompra)
1. Para un Listado de Documentos de Compra (Adaptando documentos.tsx)
Endpoint Recomendado: GET /documentos-compra/comunidad/{comunidadId}

Justificaci√≥n: Este endpoint lista los documentos de compra de una comunidad con paginaci√≥n (page, limit).

‚ö†Ô∏è Desajuste: Tu UI documentos.tsx tiene filtros mucho m√°s avanzados (b√∫squeda por texto, categor√≠a general, nivel de acceso, etiquetas) que este endpoint no soporta seg√∫n el Swagger. Tampoco devuelve estad√≠sticas ni maneja acciones masivas.

2. Para Crear un Nuevo Documento de Compra (Adaptando nuevo.tsx)
Endpoint Recomendado: POST /documentos-compra/comunidad/{comunidadId}

Justificaci√≥n: Es el endpoint para crear un nuevo registro de documento de compra.

‚ö†Ô∏è Desajuste: Tu formulario nuevo.tsx est√° dise√±ado para subir un archivo y a√±adir metadata general. Este endpoint no acepta archivos, sino campos estructurados (proveedor_id, tipo_doc, folio, fecha_emision, neto, iva, total, glosa). Necesitar√≠as un formulario completamente diferente.

3. Para Ver el Detalle de un Documento de Compra (Adaptando [id].tsx)
Endpoint Recomendado: GET /documentos-compra/{id}

Justificaci√≥n: Obtiene los detalles de un documento de compra espec√≠fico.

‚ö†Ô∏è Desajuste: Tu vista de detalle [id].tsx muestra metadata general, historial de versiones, comentarios y adjuntos.tsx]. Este endpoint probablemente devuelva solo los campos estructurados del documento de compra (folio, montos, proveedor), no versiones, comentarios, ni la metadata general.

4. Para Editar un Documento de Compra (Adaptando editar.tsx)
Endpoint Recomendado: PATCH /documentos-compra/{id}

Justificaci√≥n: Permite actualizar los campos de un documento de compra existente.

‚ö†Ô∏è Desajuste: Tu formulario editar.tsx edita la metadata general y permite subir una nueva versi√≥n del archivo. Este endpoint actualiza campos estructurados (proveedor_id, tipo_doc, folio, etc.) y no maneja subida de archivos ni versionamiento.

5. Para Eliminar un Documento de Compra (Adaptando documentos.tsx o [id].tsx)
Endpoint Recomendado: DELETE /documentos-compra/{id}

Coincidencia: Buena. Este endpoint elimina un registro de documento de compra. Podr√≠as llamarlo desde la acci√≥n de eliminar en tu listado o vista de detalle.

üí° Funcionalidades Faltantes en la API (DocumentosCompra) para Coincidir con el Frontend
Si quisieras que la API DocumentosCompra soportara las funcionalidades de tu frontend actual (lo cual cambiar√≠a su prop√≥sito de documentos estructurados a gesti√≥n documental general), necesitar√≠as a√±adir endpoints similares a los que mencion√© en la respuesta anterior sobre "Documentos":

Endpoints para adjuntar archivos: Asociar los archivos subidos (usando POST /api/files/upload) con el registro del documento de compra.

Endpoints para metadatos: Guardar y recuperar campos como categor√≠a general, nivel de acceso, etiquetas.

Endpoints para versionamiento: Gestionar el historial de versiones de los archivos adjuntos.

Endpoints para comentarios: Guardar y recuperar comentarios asociados al documento.

Filtros avanzados: Modificar el GET /documentos-compra/comunidad/{comunidadId} para soportar b√∫squeda por texto y filtros por metadatos.

Endpoints de estad√≠sticas: Para poblar las "Stats Cards".

En resumen, los componentes que proporcionaste son para un sistema diferente al que la secci√≥n DocumentosCompra de tu API define actualmente.

==========================================================


Endpoints Existentes en la API
1. Para edificios.tsx (Listado Principal)
Este componente es la p√°gina principal para listar edificios, con filtros, estad√≠sticas y vistas de tabla/tarjetas.

GET /edificios:

Coincidencia: Perfecta. Es el endpoint principal para la funci√≥n fetchEdificios. Tu API indica que soporta filtros por search, comunidadId y estado, que coinciden con los filtros de b√∫squeda, estado y tipo que usa tu UI.

GET /edificios/stats:

Coincidencia: Perfecta. Tu UI calcula las estad√≠sticas (totalEdificios, edificiosActivos, totalUnidades, ocupacion) localmente. Ser√≠a m√°s eficiente usar este endpoint de la API para obtener esas "Stats Cards" directamente.

DELETE /edificios/{id}:

Coincidencia: Perfecta. El componente tiene una funci√≥n handleDeleteEdificio. Este es el endpoint que debe llamar.

2. Para nuevo.tsx (Formulario de Creaci√≥n)
Este componente es un formulario detallado para crear un nuevo edificio.

POST /edificios:

Coincidencia: Perfecta. La funci√≥n handleSubmit llama a createEdificio(formData). Este es el endpoint correspondiente. El requestBody esperado en la API (nombre, direccion, comunidadId, etc.) coincide con los campos recolectados por el formulario.

GET /edificios/comunidades-opciones:

Coincidencia: Perfecta. El formulario necesita cargar la lista de comunidades para el selector. Este endpoint est√° dise√±ado para eso.

3. Para editar.tsx (Formulario de Edici√≥n)
Este componente carga los datos de un edificio y permite actualizarlos.

GET /edificios/{id}:

Coincidencia: Perfecta. La funci√≥n loadData usa getEdificioById(id) para rellenar el formulario. Coincide exactamente con este endpoint.

PATCH /edificios/{id}:

Coincidencia: Perfecta. La funci√≥n handleSubmit llama a updateEdificio(id, formData). Este es el endpoint para actualizaciones parciales.

PUT /edificios/{id}:

Coincidencia: Alternativa. Si la edici√≥n siempre env√≠a todos los campos, podr√≠as usar PUT en lugar de PATCH. Tu API define ambos.

GET /edificios/comunidades-opciones:

Coincidencia: Necesario. Al igual que en nuevo.tsx, este endpoint se necesita para poblar el selector de comunidades.

4. Para [id].tsx (Vista de Detalle)
Este es un componente complejo con pesta√±as para mostrar informaci√≥n detallada del edificio, sus torres, unidades y servicios.tsx].

GET /edificios/{id}:

Coincidencia: Perfecta (Carga Inicial y Pesta√±a Info). Se usa en loadEdificioData.tsx] para obtener los datos principales del edificio (nombre, direcci√≥n, estad√≠sticas r√°pidas, detalles t√©cnicos, contacto) que se muestran en el header y la pesta√±a "Informaci√≥n".tsx, swagger.json].

GET /edificios/{id}/torres:

Coincidencia: Perfecta (Pesta√±a Torres). La funci√≥n fetchTorres.tsx] se llama para poblar la pesta√±a "Torres". Este es el endpoint exacto.

GET /edificios/{id}/unidades:

Coincidencia: Perfecta (Pesta√±a Unidades). La funci√≥n fetchUnidades.tsx] se activa para la pesta√±a "Unidades" y debe usar este endpoint.

DELETE /edificios/{id}:

Coincidencia: Perfecta. El modal showDeleteModal y la funci√≥n handleDeleteEdificio.tsx] deben llamar a este endpoint para eliminar.

üí° Endpoints Sugeridos y Mejoras
POST /edificios/{id}/torres (Faltante en Vista Detalle):

Justificaci√≥n: La pesta√±a "Torres" en [id].tsx tiene un bot√≥n "Nueva Torre".tsx]. Actualmente, tu API solo define POST /edificios/{id}/torres bajo el tag Edificios, pero ser√≠a bueno confirmarlo o a√±adirlo expl√≠citamente si falta, para poder crear torres desde la vista de detalle del edificio.

POST /edificios/{id}/unidades (Faltante en Vista Detalle):

Justificaci√≥n: Similar al anterior, la pesta√±a "Unidades" en [id].tsx tiene un bot√≥n "Nueva Unidad".tsx]. La API tiene POST /edificios/{id}/unidades, necesario para esta funcionalidad.

GET /edificios/{id}/servicios o Campo en GET /edificios/{id}:

Justificaci√≥n: La pesta√±a "Servicios" en [id].tsx muestra los servicios y amenidades.tsx]. Actualmente, el GET /edificios/{id} principal no parece devolver expl√≠citamente servicios y amenidades seg√∫n el schema de swagger.json. Deber√≠as:

Opci√≥n A (Preferida): Modificar el response de GET /edificios/{id} para que incluya los arrays servicios y amenidades.

Opci√≥n B: Crear un nuevo endpoint GET /edificios/{id}/servicios-amenidades para cargarlos por separado.

Validaci√≥n de C√≥digo (GET /edificios/{id}/validar-codigo):

Prop√≥sito: Tu API ya tiene este endpoint √∫til.

Recomendaci√≥n: Podr√≠as usarlo en los formularios nuevo.tsx y editar.tsx para verificar en tiempo real si el c√≥digo ingresado ya existe, mejorando la experiencia del usuario antes de enviar el formulario.


==========================================================


Endpoints Existentes en la API
1. Para los Elementos Generales de la UI
Mensaje de Bienvenida:

GET /auth/me: Para obtener el user.username.

Selector de Comunidad:

GET /comunidades o GET /comunidades/mis-membresias: Para poblar el dropdown de comunidades (actualmente "Edificio Las Palmas").

Notificaciones:

GET /api/notificaciones/comunidad/{comunidadId}/pendientes: Ideal para obtener el contador de notificaciones no le√≠das.

GET /api/notificaciones/comunidad/{comunidadId}: Para poblar la lista desplegable de notificaciones.

2. Para las Tarjetas de KPIs (Key Performance Indicators)
Tu UI muestra: Saldo Total, Ingresos del Mes, Gastos del Mes y Tasa de Morosidad, incluyendo un % de cambio respecto al mes anterior.

Opci√≥n A (Endpoint Consolidado - Recomendado):

GET /api/dashboard/comunidad/{comunidadId}/kpis: La descripci√≥n "Obtener todos los KPIs principales del dashboard" sugiere que este endpoint podr√≠a devolver todos los valores necesarios en una sola llamada, posiblemente incluyendo la comparaci√≥n con el mes anterior.

Opci√≥n B (Endpoints Individuales): Si el endpoint consolidado no incluye todo o prefieres llamadas separadas:

GET /api/dashboard/comunidad/{comunidadId}/saldo-total: Para el Saldo Total.

GET /api/dashboard/comunidad/{comunidadId}/ingresos-mes: Para los Ingresos del Mes.

GET /api/dashboard/comunidad/{comunidadId}/gastos-mes: Para los Gastos del Mes.

GET /api/dashboard/comunidad/{comunidadId}/tasa-morosidad: Para la Tasa de Morosidad.

Nota: Necesitar√≠as verificar si estos endpoints individuales tambi√©n devuelven la comparaci√≥n porcentual con el mes anterior, o si tendr√≠as que calcularla t√∫ mismo (quiz√°s llamando al endpoint del mes anterior tambi√©n).

3. Para los Gr√°ficos (<DashboardCharts />)
El componente DashboardCharts probablemente necesite datos de tendencias o distribuciones. Tu API ofrece varios endpoints espec√≠ficos para gr√°ficos:

GET /api/dashboard/comunidad/{comunidadId}/grafico-emisiones: Tendencia de emisiones (√∫ltimos 6 meses).

GET /api/dashboard/comunidad/{comunidadId}/grafico-estado-pagos: Distribuci√≥n de estado de pagos.

GET /api/dashboard/comunidad/{comunidadId}/grafico-gastos-categoria: Gastos por categor√≠a (mes actual).

GET /api/dashboard/comunidad/{comunidadId}/tendencia-ingresos: Tendencia de crecimiento de ingresos.

4. Para las Tablas y Listas
Pagos Recientes:

GET /api/dashboard/comunidad/{comunidadId}/pagos-recientes: Coincidencia perfecta. Acepta un par√°metro limit.

Unidades con Morosidad:

GET /api/dashboard/comunidad/{comunidadId}/unidades-morosas: Coincidencia perfecta. Acepta un par√°metro limit.

Pr√≥ximas Actividades:

GET /api/dashboard/comunidad/{comunidadId}/proximas-actividades: Coincidencia perfecta. Acepta un par√°metro limit.

Reservas de Amenidades:

GET /api/dashboard/comunidad/{comunidadId}/reservas-amenidades: Coincidencia perfecta. Acepta un par√°metro limit.

‚≠ê Opci√≥n √ìptima (Endpoint √önico)
GET /api/dashboard/comunidad/{comunidadId}/resumen-completo:

Descripci√≥n: "Resumen completo del dashboard (todos los datos en una sola llamada)".

Recomendaci√≥n: Este es probablemente el endpoint m√°s eficiente. Deber√≠as investigar su respuesta para ver si incluye todos los datos necesarios (KPIs, datos para gr√°ficos, listas recientes). Si es as√≠, podr√≠as cargar casi todo el dashboard con una sola llamada a la API, lo cual es ideal para el rendimiento.

En resumen, la secci√≥n /api/dashboard/ de tu API est√° muy bien alineada con tu componente dashboard.tsx. Tienes endpoints espec√≠ficos para casi cada secci√≥n, y un endpoint consolidado que podr√≠a ser la mejor opci√≥n.